# -*- coding: utf-8 -*-
"""LogisticRAlgorithm.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/19KUIBf--9K0iq9JI4BBeR_bNjTvYz4zk

This program have some functions used by Jason Brownlee to scale and get the dataset
"""

import math
import numpy as np
import matplotlib.pyplot as plt
from csv import reader
from random import random

"""This program have some functions used by Jason Brownlee to scale and get the dataset"""

"""The next block of code is the one that is in charge of cleaning, building, spliting and scaling the ds"""

def load_csv(filename):
  """ This function cleans the dataset from the rows that have Null and retur a clean dataset"""
  dataset = []
  n = 4000
  with open(filename, 'r') as file:
      csvReader =  reader(file)
      for row in csvReader:
        if (not row) or ("NA" in row) or n < 0:
          continue
        dataset.append(row)
        n = n-1
  dataset.pop(0)#This is to skip the names of the columns
  return dataset


def str_column_to_float(dataset):#This changes all the values to float values, to avoid problems with max function
  for i in range(len(dataset[0])):
    for row in dataset:
      if(row[i] == 'No'):
        row[i] = 0
      elif(row[i] == 'Yes'):
        row[i] = 1
      row[i] = float(row[i])

def scale(dataset): #this gives us values between -1 and 1
  minmax = []
  for i in range(len(dataset[0])): #This is looking in each column, row example:['0', '39', '4', '1', '9', '0', '0', '0', '0', '170', '110.5', '69', '22.19', '60', '103', '0']
    columnValues = [row[i] for row in dataset]
    acum = 0
    for row in columnValues:
      acum += row
    value_min = min(columnValues)
    value_max = max(columnValues)
    minmax.append([value_min, value_max])
  for row in dataset:
    for i in range(len(row)):
      if(minmax[i][0] != 1 and (minmax[i][1] - minmax[i][0]) != 0 ):
         row[i] = (row[i] - minmax[i][0]) / (minmax[i][1] - minmax[i][0])

def getYX(ds):
  y = []
  for row in ds:
    temp = row.pop(len(row)-1)
    row.append(1)
    y.append(temp)
  return y

def splitDs (dataset,splits):
  splitData = []
  cpyDs = list(dataset)
  splitSize = int(len(dataset)/splits)
  for i in range(splits):
    split= []
    for j in range(splitSize):
      split.append(cpyDs.pop())
    splitData.append(split)
  return splitData

def getDs(filename): #Build the complete and clean ds
  ds = load_csv(filename)
  str_column_to_float(ds)
  scale(ds)
  return splitDs(ds,2)

"""The next block is the one with the full algorithm of the Loggistic regression"""

def hy(weights, x):
  """ This function makes the hypothesis for the Logistic regressios
      weights: are the parameters that multiplies their respective x
      x: are the values from one sample
  """ 
  hyp = 0
  for i in range(len(weights)):
    hyp+=(weights[i]*x[i])
    x[i]
  hyp = hyp * (-1)
  hyp = 1/(1+ math.exp (hyp))
  return hyp

def gD(weights,x,y,a):
  """ Gradient descend function """
  temp=list(weights)
  for j in range(len(weights)):
    acum=0
    for i in range(len(x)):
      err=hy(weights,x[i])-y[i]
      acum+=err*x[i][j]
    temp[j]=weights[j]-a*(1/len(x))*acum
  return temp

"""The next block helps in monitoring the error of the model and its changes"""

def error(weights,x,y):
  acumError = 0
  avgError = 0
  for i in range(len(x)):
    hyp = hy(weights,x[i])
    if(y[i] == 1): # avoid the log(0) error
      if(hyp ==0):
        hyp = .0001
      error = (-1)*math.log(hyp)
    if(y[i] == 0):
      if(hyp ==1):
        hyp = .9999
      error = (-1)*math.log(1-hyp)
    acumError += error
  #print( "error %f  hyp  %f  y %f " % (error, hyp,  y[i]))
  avgError = acumError/ len(x)
  return avgError

"""The next block its the function for the test part"""

def test(weights,x,y):
  print("\n \n Start test")
  acumLogError = 0
  accuracy = 0
  for i in range(len(x)):
    hyp = hy(weights,x[i])
    if(y[i] == 1.0): # avoid the log(0) error
      if(hyp ==0):
        hyp = .0001
      logError = (-1)*math.log(hyp)
      if(hyp > .5):
        accuracy = accuracy +1
    if(y[i] == 0.0):
      if(hyp ==1):
        hyp = .9999
      logError = (-1)*math.log(1-hyp)
      if(hyp < .5):
        accuracy = accuracy +1
    acumLogError += logError
    if (hyp >.5):
      act = 1
    else:
      act = 0
    print( "logError %f  hyp  %f activation %i y %f " % (logError,hyp, act, y[i]))
  avgLogError = acumLogError/len(x)
  accuracy = (accuracy * 100)/ len(x)
  print("Accuracy:",accuracy)
  print(avgLogError)

"""And the last block its the one that calls the functions, its the main function"""

a = .8
weights =[]
for i in range(14):
  weights.append(random())
ds = getDs("weatherAUS.csv")
dsTrainY = getYX(ds[0])
dsTrainX = ds[0]
dsTestY = getYX(ds[1])
dsTestX = ds[1]
epoch = 3000
err = 1
graph = []

while err > .20 and epoch > 0:
  temp = list(weights)
  weights = gD(weights, dsTrainX, dsTrainY,a)
  err = error(weights,dsTrainX,dsTrainY)
  graph.append(err)
  print(err)
  epoch = epoch - 1

print("Weights:")
print(weights)
plt.plot(graph)

test(weights,dsTestX,dsTestY)
